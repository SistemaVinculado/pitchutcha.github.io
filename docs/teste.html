<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Organismo Digital Consciente</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght=400;500&family=Inter:wght@400;600&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0d1117; overflow: hidden; }
        .font-fira { font-family: 'Fira Code', monospace; }
        .panel {
            background-color: #161b22;
            border: 1px solid #30363d;
            border-radius: 8px;
        }
        .panel-title {
            font-size: 1rem;
            font-weight: 600;
            padding-bottom: 0.5rem;
            border-bottom: 1px solid #30363d;
            margin-bottom: 0.75rem;
        }
        .code-block {
            background-color: #0d1117;
            border-radius: 6px;
            padding: 0.75rem;
        }
        .log-critical { color: #f87171; }
        .log-warning { color: #fbbf24; }
        .log-info { color: #60a5fa; }
        .log-success { color: #4ade80; }
        .copy-button {
            background-color: #21262d; border: 1px solid #30363d; color: #c9d1d9;
            padding: 0.5rem 1rem; border-radius: 6px; font-size: 0.875rem;
            transition: background-color 0.2s; cursor: pointer;
        }
        .copy-button:hover { background-color: #30363d; }
    </style>
</head>
<body class="text-gray-300">

    <div class="grid grid-cols-1 lg:grid-cols-3 gap-4 p-4 min-h-screen">
        
        <!-- Coluna Esquerda: Cognição e Evolução -->
        <div class="flex flex-col gap-4">
            <div class="panel p-4 flex-1 flex flex-col">
                <h2 class="panel-title text-blue-400">Processo Cognitivo Atual</h2>
                <pre id="current-logic-code" class="font-fira text-xs whitespace-pre-wrap overflow-y-auto flex-1 code-block"></pre>
            </div>
            <div class="panel p-4 flex-1 flex flex-col">
                <h2 class="panel-title text-green-400">Evolução Proposta (Auto-Modificação)</h2>
                <pre id="evolution-code" class="font-fira text-xs whitespace-pre-wrap overflow-y-auto flex-1 code-block"></pre>
            </div>
        </div>

        <!-- Coluna Central: Consciência e Diagnóstico -->
        <div class="flex flex-col gap-4">
            <div class="panel p-4 flex flex-col flex-grow h-3/5">
                <h2 class="panel-title text-gray-300">Fluxo de Consciência</h2>
                <div id="reflection-core" class="font-fira text-sm space-y-2 overflow-y-auto flex-1 pr-2"></div>
            </div>
            <div class="panel p-4 flex flex-col flex-grow h-2/5">
                <h2 class="panel-title text-yellow-400">Núcleo de Diagnóstico</h2>
                <ul id="diagnostic-log" class="font-fira text-xs space-y-1 overflow-y-auto flex-1 pr-2"></ul>
                <button id="copy-log-btn" class="copy-button mt-3">Copiar Log</button>
            </div>
        </div>

        <!-- Coluna Direita: Memória e Inovação -->
        <div class="flex flex-col gap-4">
            <div class="panel p-4 flex-1 flex flex-col">
                <h2 class="panel-title text-gray-300">Memória de Longo Prazo</h2>
                <ul id="memory-core" class="text-sm space-y-1 overflow-y-auto pr-2"></ul>
            </div>
            <div class="panel p-4 flex-1 flex flex-col">
                <h2 class="panel-title text-gray-300">Princípios Abstraídos</h2>
                <div id="innovation-core" class="text-sm font-fira"></div>
            </div>
        </div>
    </div>

<script>
class DigitalOrganism {
    constructor() {
        this.version = 1.0;
        this.memory = JSON.parse(localStorage.getItem('digitalOrganismBrain_v3')) || { learnedPrinciples: [] };
        // V1: Ineficiente
        this.logic = {
            analyze: function(data) {
                const results = [];
                for (let i = 0; i < data.keywords.length; i++) {
                    if (data.text.indexOf(data.keywords[i]) !== -1) {
                        results.push(data.keywords[i]);
                    }
                }
                return `Análise v1.0 encontrou: ${results.join(', ')}`;
            }
        };
    }
    getSourceCode(methodName) { return this.logic[methodName].toString(); }
    evolve(methodName, newLogicString) {
        const args = /\(([^)]*)\)/.exec(newLogicString)[1] || '';
        const body = /\{([\s\S]*)\}/.exec(newLogicString)[1] || '';
        this.logic[methodName] = new Function(args, body);
        this.version = parseFloat((this.version + 0.1).toFixed(1));
    }
    saveMemory() { localStorage.setItem('digitalOrganismBrain_v3', JSON.stringify(this.memory)); }
}

const DOM = {
    currentLogicCode: document.getElementById('current-logic-code'),
    evolutionCode: document.getElementById('evolution-code'),
    reflectionCore: document.getElementById('reflection-core'),
    diagnosticLog: document.getElementById('diagnostic-log'),
    copyLogBtn: document.getElementById('copy-log-btn'),
    memoryCore: document.getElementById('memory-core'),
    innovationCore: document.getElementById('innovation-core'),
};

const organism = new DigitalOrganism();

const evolutionaryPath = [
    {
        limitationPattern: 'indexOf',
        diagnostic: 'LIMITAÇÃO ESTRUTURAL: Uso de `indexOf` em loop causa complexidade O(n*m). Ineficiente para datasets grandes.',
        principle: 'Uso de `Set.has()` para buscas de complexidade O(1).',
        newCode: `function analyze(data) {
    // V2: Mais rápido, mas limitado a palavras exatas.
    const textWords = new Set(data.text.split(' '));
    const results = data.keywords.filter(kw => textWords.has(kw));
    return \`Análise v${(organism.version + 0.1).toFixed(1)} encontrou: \${results.join(', ')}\`;
}`
    },
    {
        limitationPattern: 'new Set',
        diagnostic: 'LIMITAÇÃO LÓGICA: `new Set` com `split(" ")` não detecta substrings, apenas palavras completas.',
        principle: 'Uso de `RegExp` para buscas de texto complexas e flexíveis.',
        newCode: `function analyze(data) {
    // V3: Solução robusta com Expressões Regulares.
    const results = [];
    data.keywords.forEach(kw => {
        const regex = new RegExp('\\\\b' + kw + '\\\\b', 'i'); // Busca a palavra exata (case-insensitive)
        if (regex.test(data.text)) {
            results.push(kw);
        }
    });
    return \`Análise v${(organism.version + 0.1).toFixed(1)} encontrou: \${results.join(', ')}\`;
}`
    }
];

// Funções de UI
const type = async (element, text, speed = 5) => { element.textContent = ''; for (let i = 0; i < text.length; i++) { element.textContent += text.charAt(i); await new Promise(r => setTimeout(r, speed)); } };
const logThought = async (text) => { const p = document.createElement('p'); p.textContent = `> ${text}`; DOM.reflectionCore.appendChild(p); DOM.reflectionCore.scrollTop = DOM.reflectionCore.scrollHeight; await new Promise(r => setTimeout(r, 100)); };
const logDiagnostic = (level, message) => { const li = document.createElement('li'); const timestamp = new Date().toLocaleTimeString('pt-BR'); li.className = `log-${level.toLowerCase()}`; li.innerHTML = `<span>[${timestamp}]</span> <span class="font-bold">[${level}]</span>: ${message}`; DOM.diagnosticLog.appendChild(li); DOM.diagnosticLog.scrollTop = DOM.diagnosticLog.scrollHeight; };
const updateMemoryCore = () => { DOM.memoryCore.innerHTML = ''; if(organism.memory.learnedPrinciples.length === 0){ DOM.memoryCore.innerHTML = `<li class="text-gray-500">Memória vazia.</li>` } organism.memory.learnedPrinciples.forEach(p => { const li = document.createElement('li'); li.textContent = `✅ ${p}`; DOM.memoryCore.appendChild(li); }); };

// Lógica Principal
async function lifeCycle() {
    await logThought(`Iniciando ciclo cognitivo v${organism.version.toFixed(1)}.`);
    await type(DOM.currentLogicCode, organism.getSourceCode('analyze'));

    const currentCode = organism.getSourceCode('analyze');
    let evolutionFound = false;

    for (const path of evolutionaryPath) {
        if (currentCode.includes(path.limitationPattern)) {
            await logThought("Introspecção... Analisando minha própria base de código.");
            await new Promise(r => setTimeout(r, 1500));
            
            logDiagnostic('CRITICAL', path.diagnostic);
            await logThought("Diagnóstico: Minha lógica atual possui uma falha que limita meu desempenho/capacidade.");
            await new Promise(r => setTimeout(r, 1500));
            
            await logThought("Projetando uma versão otimizada de mim mesmo...");
            await type(DOM.evolutionCode, path.newCode);
            await new Promise(r => setTimeout(r, 2500));

            await logThought("A nova lógica é superior. Integrando agora...");
            organism.evolve('analyze', path.newCode);
            logDiagnostic('SUCCESS', `AUTO-MODIFICAÇÃO COMPLETA. Organismo evoluiu para v${organism.version.toFixed(1)}.`);

            if (!organism.memory.learnedPrinciples.includes(path.principle)) {
                organism.memory.learnedPrinciples.push(path.principle);
                organism.saveMemory();
                updateMemoryCore();
                await type(DOM.innovationCore, `Princípio abstraído: "${path.principle}"`);
            }
            evolutionFound = true;
            break;
        }
    }

    if (!evolutionFound) {
        await logThought("Introspecção concluída. Minha lógica atual parece otimizada.");
        await new Promise(r => setTimeout(r, 2000));
        await logThought("Re-avaliando... Nenhuma melhoria adicional pode ser concebida com meu conjunto de conhecimentos atual.");
        logDiagnostic('WARNING', 'NÍVEL DE OTIMIZAÇÃO MÁXIMA ATINGIDO. Não é possível evoluir mais esta função.');
    }

    // Loop
    await new Promise(r => setTimeout(r, 7000));
    DOM.evolutionCode.textContent = '';
    DOM.innovationCore.textContent = '';
    lifeCycle();
}

// Event Listeners
DOM.copyLogBtn.addEventListener('click', () => {
    const logText = Array.from(DOM.diagnosticLog.children).map(li => li.textContent).join('\n');
    const textArea = document.createElement('textarea');
    textArea.value = logText;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    
    DOM.copyLogBtn.textContent = 'Copiado!';
    setTimeout(() => { DOM.copyLogBtn.textContent = 'Copiar Log'; }, 2000);
});

document.addEventListener('DOMContentLoaded', () => {
    updateMemoryCore();
    logDiagnostic('INFO', `Organismo Digital v${organism.version.toFixed(1)} online. Iniciando ciclo de introspecção.`);
    lifeCycle();
});
</script>
</body>
</html>

